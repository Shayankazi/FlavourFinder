{"ast":null,"code":"var _jsxFileName = \"/Users/shayankazi/PROJECTS/Thadomal/2 va/receipe-recommender/src/components/Plasma.jsx\",\n  _s = $RefreshSig$();\nimport React, { useRef, useMemo } from 'react';\nimport { Canvas, useFrame } from '@react-three/fiber';\nimport { ShaderMaterial } from 'three';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst PlasmaShader = ({\n  color = \"#ff6b35\",\n  speed = 0.6,\n  direction = \"forward\",\n  scale = 1.1,\n  opacity = 0.8,\n  mouseInteractive = true\n}) => {\n  _s();\n  const meshRef = useRef();\n  const mouseRef = useRef({\n    x: 0,\n    y: 0\n  });\n\n  // Handle mouse interaction\n  React.useEffect(() => {\n    if (!mouseInteractive) return;\n    const handleMouseMove = event => {\n      mouseRef.current.x = event.clientX / window.innerWidth * 2 - 1;\n      mouseRef.current.y = -(event.clientY / window.innerHeight) * 2 + 1;\n    };\n    window.addEventListener('mousemove', handleMouseMove);\n    return () => window.removeEventListener('mousemove', handleMouseMove);\n  }, [mouseInteractive]);\n\n  // Convert hex color to RGB\n  const hexToRgb = hex => {\n    const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    return result ? {\n      r: parseInt(result[1], 16) / 255,\n      g: parseInt(result[2], 16) / 255,\n      b: parseInt(result[3], 16) / 255\n    } : {\n      r: 1,\n      g: 0.42,\n      b: 0.21\n    };\n  };\n  const colorRgb = hexToRgb(color);\n  const shaderMaterial = useMemo(() => {\n    return new ShaderMaterial({\n      uniforms: {\n        u_time: {\n          value: 0\n        },\n        u_resolution: {\n          value: [window.innerWidth, window.innerHeight]\n        },\n        u_mouse: {\n          value: [0, 0]\n        },\n        u_color: {\n          value: [colorRgb.r, colorRgb.g, colorRgb.b]\n        },\n        u_speed: {\n          value: speed\n        },\n        u_scale: {\n          value: scale\n        },\n        u_opacity: {\n          value: opacity\n        },\n        u_direction: {\n          value: direction === \"forward\" ? 1.0 : -1.0\n        }\n      },\n      vertexShader: `\n        varying vec2 vUv;\n        void main() {\n          vUv = uv;\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }\n      `,\n      fragmentShader: `\n        uniform float u_time;\n        uniform vec2 u_resolution;\n        uniform vec2 u_mouse;\n        uniform vec3 u_color;\n        uniform float u_speed;\n        uniform float u_scale;\n        uniform float u_opacity;\n        uniform float u_direction;\n        varying vec2 vUv;\n\n        // Noise function\n        float noise(vec2 p) {\n          return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n        }\n\n        // Smooth noise\n        float smoothNoise(vec2 p) {\n          vec2 i = floor(p);\n          vec2 f = fract(p);\n          f = f * f * (3.0 - 2.0 * f);\n          \n          float a = noise(i);\n          float b = noise(i + vec2(1.0, 0.0));\n          float c = noise(i + vec2(0.0, 1.0));\n          float d = noise(i + vec2(1.0, 1.0));\n          \n          return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n        }\n\n        // Fractal noise\n        float fractalNoise(vec2 p) {\n          float value = 0.0;\n          float amplitude = 0.5;\n          float frequency = 1.0;\n          \n          for(int i = 0; i < 4; i++) {\n            value += amplitude * smoothNoise(p * frequency);\n            amplitude *= 0.5;\n            frequency *= 2.0;\n          }\n          \n          return value;\n        }\n\n        void main() {\n          vec2 uv = vUv;\n          vec2 p = (uv - 0.5) * u_scale;\n          \n          // Add mouse interaction\n          vec2 mouse = u_mouse * 0.1;\n          p += mouse;\n          \n          // Time with direction and speed\n          float time = u_time * u_speed * u_direction;\n          \n          // Create plasma effect\n          float plasma1 = sin(p.x * 10.0 + time);\n          float plasma2 = sin(p.y * 8.0 + time * 1.2);\n          float plasma3 = sin((p.x + p.y) * 6.0 + time * 0.8);\n          float plasma4 = sin(sqrt(p.x * p.x + p.y * p.y) * 12.0 + time * 1.5);\n          \n          // Add fractal noise for more complexity\n          float noise1 = fractalNoise(p * 3.0 + time * 0.1);\n          float noise2 = fractalNoise(p * 5.0 - time * 0.15);\n          \n          // Combine all effects\n          float plasma = (plasma1 + plasma2 + plasma3 + plasma4) * 0.25;\n          plasma += (noise1 + noise2) * 0.3;\n          \n          // Create color variations\n          vec3 color1 = u_color;\n          vec3 color2 = u_color * 0.7 + vec3(0.2, 0.1, 0.3);\n          vec3 color3 = u_color * 1.2 + vec3(0.1, 0.2, 0.1);\n          \n          // Mix colors based on plasma value\n          vec3 finalColor = mix(color1, color2, sin(plasma * 2.0) * 0.5 + 0.5);\n          finalColor = mix(finalColor, color3, sin(plasma * 3.0 + time) * 0.3 + 0.3);\n          \n          // Add some brightness variation\n          float brightness = 0.8 + sin(plasma * 4.0 + time * 2.0) * 0.2;\n          finalColor *= brightness;\n          \n          gl_FragColor = vec4(finalColor, u_opacity);\n        }\n      `,\n      transparent: true\n    });\n  }, [color, speed, scale, opacity, direction, colorRgb]);\n  useFrame(state => {\n    if (meshRef.current) {\n      shaderMaterial.uniforms.u_time.value = state.clock.elapsedTime;\n      if (mouseInteractive) {\n        shaderMaterial.uniforms.u_mouse.value = [mouseRef.current.x, mouseRef.current.y];\n      }\n    }\n  });\n  return /*#__PURE__*/_jsxDEV(\"mesh\", {\n    ref: meshRef,\n    material: shaderMaterial,\n    children: /*#__PURE__*/_jsxDEV(\"planeGeometry\", {\n      args: [2, 2]\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 161,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 160,\n    columnNumber: 5\n  }, this);\n};\n_s(PlasmaShader, \"c3pQ/XitbSBedEJcZSFEjqG9YoI=\", false, function () {\n  return [useFrame];\n});\n_c = PlasmaShader;\nconst Plasma = ({\n  color = \"#ff6b35\",\n  speed = 0.6,\n  direction = \"forward\",\n  scale = 1.1,\n  opacity = 0.8,\n  mouseInteractive = true,\n  className = \"\"\n}) => {\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: `plasma-container ${className}`,\n    children: /*#__PURE__*/_jsxDEV(Canvas, {\n      camera: {\n        position: [0, 0, 1]\n      },\n      dpr: Math.min(window.devicePixelRatio, 2),\n      style: {\n        position: 'fixed',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: '100%',\n        zIndex: -1,\n        pointerEvents: 'none'\n      },\n      children: /*#__PURE__*/_jsxDEV(PlasmaShader, {\n        color: color,\n        speed: speed,\n        direction: direction,\n        scale: scale,\n        opacity: opacity,\n        mouseInteractive: mouseInteractive\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 190,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 177,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 176,\n    columnNumber: 5\n  }, this);\n};\n_c2 = Plasma;\nexport default Plasma;\nvar _c, _c2;\n$RefreshReg$(_c, \"PlasmaShader\");\n$RefreshReg$(_c2, \"Plasma\");","map":{"version":3,"names":["React","useRef","useMemo","Canvas","useFrame","ShaderMaterial","jsxDEV","_jsxDEV","PlasmaShader","color","speed","direction","scale","opacity","mouseInteractive","_s","meshRef","mouseRef","x","y","useEffect","handleMouseMove","event","current","clientX","window","innerWidth","clientY","innerHeight","addEventListener","removeEventListener","hexToRgb","hex","result","exec","r","parseInt","g","b","colorRgb","shaderMaterial","uniforms","u_time","value","u_resolution","u_mouse","u_color","u_speed","u_scale","u_opacity","u_direction","vertexShader","fragmentShader","transparent","state","clock","elapsedTime","ref","material","children","args","fileName","_jsxFileName","lineNumber","columnNumber","_c","Plasma","className","camera","position","dpr","Math","min","devicePixelRatio","style","top","left","width","height","zIndex","pointerEvents","_c2","$RefreshReg$"],"sources":["/Users/shayankazi/PROJECTS/Thadomal/2 va/receipe-recommender/src/components/Plasma.jsx"],"sourcesContent":["import React, { useRef, useMemo } from 'react';\nimport { Canvas, useFrame } from '@react-three/fiber';\nimport { ShaderMaterial } from 'three';\n\nconst PlasmaShader = ({ \n  color = \"#ff6b35\", \n  speed = 0.6, \n  direction = \"forward\", \n  scale = 1.1, \n  opacity = 0.8,\n  mouseInteractive = true \n}) => {\n  const meshRef = useRef();\n  const mouseRef = useRef({ x: 0, y: 0 });\n\n  // Handle mouse interaction\n  React.useEffect(() => {\n    if (!mouseInteractive) return;\n\n    const handleMouseMove = (event) => {\n      mouseRef.current.x = (event.clientX / window.innerWidth) * 2 - 1;\n      mouseRef.current.y = -(event.clientY / window.innerHeight) * 2 + 1;\n    };\n\n    window.addEventListener('mousemove', handleMouseMove);\n    return () => window.removeEventListener('mousemove', handleMouseMove);\n  }, [mouseInteractive]);\n\n  // Convert hex color to RGB\n  const hexToRgb = (hex) => {\n    const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    return result ? {\n      r: parseInt(result[1], 16) / 255,\n      g: parseInt(result[2], 16) / 255,\n      b: parseInt(result[3], 16) / 255\n    } : { r: 1, g: 0.42, b: 0.21 };\n  };\n\n  const colorRgb = hexToRgb(color);\n\n  const shaderMaterial = useMemo(() => {\n    return new ShaderMaterial({\n      uniforms: {\n        u_time: { value: 0 },\n        u_resolution: { value: [window.innerWidth, window.innerHeight] },\n        u_mouse: { value: [0, 0] },\n        u_color: { value: [colorRgb.r, colorRgb.g, colorRgb.b] },\n        u_speed: { value: speed },\n        u_scale: { value: scale },\n        u_opacity: { value: opacity },\n        u_direction: { value: direction === \"forward\" ? 1.0 : -1.0 }\n      },\n      vertexShader: `\n        varying vec2 vUv;\n        void main() {\n          vUv = uv;\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }\n      `,\n      fragmentShader: `\n        uniform float u_time;\n        uniform vec2 u_resolution;\n        uniform vec2 u_mouse;\n        uniform vec3 u_color;\n        uniform float u_speed;\n        uniform float u_scale;\n        uniform float u_opacity;\n        uniform float u_direction;\n        varying vec2 vUv;\n\n        // Noise function\n        float noise(vec2 p) {\n          return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n        }\n\n        // Smooth noise\n        float smoothNoise(vec2 p) {\n          vec2 i = floor(p);\n          vec2 f = fract(p);\n          f = f * f * (3.0 - 2.0 * f);\n          \n          float a = noise(i);\n          float b = noise(i + vec2(1.0, 0.0));\n          float c = noise(i + vec2(0.0, 1.0));\n          float d = noise(i + vec2(1.0, 1.0));\n          \n          return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n        }\n\n        // Fractal noise\n        float fractalNoise(vec2 p) {\n          float value = 0.0;\n          float amplitude = 0.5;\n          float frequency = 1.0;\n          \n          for(int i = 0; i < 4; i++) {\n            value += amplitude * smoothNoise(p * frequency);\n            amplitude *= 0.5;\n            frequency *= 2.0;\n          }\n          \n          return value;\n        }\n\n        void main() {\n          vec2 uv = vUv;\n          vec2 p = (uv - 0.5) * u_scale;\n          \n          // Add mouse interaction\n          vec2 mouse = u_mouse * 0.1;\n          p += mouse;\n          \n          // Time with direction and speed\n          float time = u_time * u_speed * u_direction;\n          \n          // Create plasma effect\n          float plasma1 = sin(p.x * 10.0 + time);\n          float plasma2 = sin(p.y * 8.0 + time * 1.2);\n          float plasma3 = sin((p.x + p.y) * 6.0 + time * 0.8);\n          float plasma4 = sin(sqrt(p.x * p.x + p.y * p.y) * 12.0 + time * 1.5);\n          \n          // Add fractal noise for more complexity\n          float noise1 = fractalNoise(p * 3.0 + time * 0.1);\n          float noise2 = fractalNoise(p * 5.0 - time * 0.15);\n          \n          // Combine all effects\n          float plasma = (plasma1 + plasma2 + plasma3 + plasma4) * 0.25;\n          plasma += (noise1 + noise2) * 0.3;\n          \n          // Create color variations\n          vec3 color1 = u_color;\n          vec3 color2 = u_color * 0.7 + vec3(0.2, 0.1, 0.3);\n          vec3 color3 = u_color * 1.2 + vec3(0.1, 0.2, 0.1);\n          \n          // Mix colors based on plasma value\n          vec3 finalColor = mix(color1, color2, sin(plasma * 2.0) * 0.5 + 0.5);\n          finalColor = mix(finalColor, color3, sin(plasma * 3.0 + time) * 0.3 + 0.3);\n          \n          // Add some brightness variation\n          float brightness = 0.8 + sin(plasma * 4.0 + time * 2.0) * 0.2;\n          finalColor *= brightness;\n          \n          gl_FragColor = vec4(finalColor, u_opacity);\n        }\n      `,\n      transparent: true\n    });\n  }, [color, speed, scale, opacity, direction, colorRgb]);\n\n  useFrame((state) => {\n    if (meshRef.current) {\n      shaderMaterial.uniforms.u_time.value = state.clock.elapsedTime;\n      if (mouseInteractive) {\n        shaderMaterial.uniforms.u_mouse.value = [mouseRef.current.x, mouseRef.current.y];\n      }\n    }\n  });\n\n  return (\n    <mesh ref={meshRef} material={shaderMaterial}>\n      <planeGeometry args={[2, 2]} />\n    </mesh>\n  );\n};\n\nconst Plasma = ({ \n  color = \"#ff6b35\", \n  speed = 0.6, \n  direction = \"forward\", \n  scale = 1.1, \n  opacity = 0.8,\n  mouseInteractive = true,\n  className = \"\"\n}) => {\n  return (\n    <div className={`plasma-container ${className}`}>\n      <Canvas\n        camera={{ position: [0, 0, 1] }}\n        dpr={Math.min(window.devicePixelRatio, 2)}\n        style={{\n          position: 'fixed',\n          top: 0,\n          left: 0,\n          width: '100%',\n          height: '100%',\n          zIndex: -1,\n          pointerEvents: 'none'\n        }}\n      >\n        <PlasmaShader \n          color={color}\n          speed={speed}\n          direction={direction}\n          scale={scale}\n          opacity={opacity}\n          mouseInteractive={mouseInteractive}\n        />\n      </Canvas>\n    </div>\n  );\n};\n\nexport default Plasma;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}